{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1 @@\n-    main()\n+",
        "start_line": 115,
        "end_line": null
    },
    "C0103 - Module name \"E0701-bad_except_clauses_order\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,115 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    try:\n-        image = SimpleImage(front_filename)\n-        back = SimpleImage(back_filename)\n-        for y in range(image.height):\n-            for x in range(image.width):\n-                pixel = image.get_pixel(x, y)\n-                if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                    back_pixel = back.get_pixel(x, y)\n-                    image.set_pixel(x, y, back_pixel)\n-        return image\n-    except Exception as e:\n-        print(f\"An error occurred: {e}\")\n-    except ValueError:  # Bad except clauses order (E0701)\n-        print(\"ValueError should be caught before Exception\")\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "W0718 - Catching too general exception Exception": {
        "diff": "--- \n+++ \n@@ -1 +1,139 @@\n+\n+\n+    \"\"\"\n+    # read file \n+    with open(file_path) as f:\n+        src = f.read()\n+    \n+    # remove comments\n+    src = py_comments.remove_comments(src)\n+\n+    # run pylint on source and get report\n+    linter_report = run_pylint(file_path, src)\n+\n+    # check for exceptions \n+    if 'Exception' in linter_report or 'except Exception as e:' in linter_report:\n+        return [src], linter_report\n+    \n+    # find lines to be deleted, and fix them\n+    # TODO: make a function to do this\n+    code_lines = src.split('\\n')\n+\n+    # find the line number of the first occurrence of \"return\"\n+    try:\n+        start_line = src[src.index(\"def\") + 4 :].index('return')\n+        end_line = start_line + 1\n+    except ValueError:\n+        return [src], linter_report\n+    \n+    for index, code in enumerate(code_lines):\n+        if 'return' in code and index >= start_line and index <= end_line:\n+            new_line = re.search('(?<=return)\\s*([a-zA-Z0-9_]*),', src).group() \n+            new_code = py_comments.add_comment(src, \n+                                            'This code was added by the post fixer.',\n+                                            index=index)\n+            if 'print' in new_line:\n+                return [new_code], linter_report\n+            else:\n+                return [py_comments.replace_text(new_code, src)], linter_report\n+\n+\n+def get_response(file_path):\n+    \"\"\"\n+        This is the function where we will execute all of the post fixers and return their results\n+        in a single list. If an exception occurs inside any post fixer then it should be handled by this method. \n+        The code here is inspired by stack overflow: https://stackoverflow.com/questions/4065728/how-to-catch-exception-inside-try-except\n+    \"\"\"\n+\n+    try:\n+        with open(file_path) as f:\n+            src = f.read()\n+\n+        # remove comments\n+        src = py_comments.remove_comments(src)\n+\n+        # run pylint on source and get report\n+        linter_report = run_pylint(file_path, src)\n+        \n+        # check for exceptions \n+        if 'Exception' in linter_report or 'except Exception as e:' in linter_report:\n+            return [src], linter_report\n+        \n+        # find lines to be deleted, and fix them\n+        # TODO: make a function to do this\n+        code_lines = src.split('\\n')\n+\n+        # get the number of post-fixers that have been implemented\n+        # we will use this to know whether or not we should return results as a list\n+        num_post_fixers = len(POST_FIXERS)\n+        \n+        # find the line number of the first occurrence of \"return\"\n+        try:\n+            start_line = src[src.index(\"def\") + 4 :].index('return')\n+            end_line = start_line + 1\n+        except ValueError:\n+            return [src], linter_report\n+\n+        for index, code in enumerate(code_lines):\n+            # if the post-fixer has not been implemented then just return the source\n+            if index >= start_line and index <= end_line:\n+                continue\n+\n+            try:\n+                # execute post fixers and get results\n+                post_fixer = POST_FIXERS[index]\n+\n+                fixed_src, linter_report = post_fixer(file_path, src, code)\n+                \n+                # check for exceptions \n+                if 'Exception' in linter_report or 'except Exception as e:' in linter_report:\n+                    return [src], linter_report\n+                else:\n+                    return fixed_src, linter_report\n+\n+            except KeyError:\n+                # if the post-fixer has not been implemented then just return the source\n+                return [src], linter_report\n+            finally:\n+                if num_post_fixers == 1:\n+                    continue\n+\n+                # decrement the number of post-fixers left to run\n+                num_post_fixers -= 1\n+\n+    except FileNotFoundError as e:\n+        raise ValueError(f\"File {file_path} not found!\")\n     except Exception as e:\n+        raise e\n+\n+\n+def generate_response(file_paths):\n+    \"\"\"\n+        This is a utility function that takes in a list of file paths and returns the response for each \n+        file. If any exception occurs then it should be handled by this method. \n+    \"\"\"\n+    # execute all post-fixers on all files\n+    responses = [get_response(f) for f in tqdm(file_paths)]\n+\n+    # flatten all responses\n+    flat_responses = [item for sublist in responses for item in sublist]\n+\n+    return flat_responses\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"This is a utility that can be used to lint source files and execute post-fixers on them.\")\n+\n+    parser.add_argument(\"-f\", \"--file-path\", nargs='+', help=\"Provide the paths for the file or files you want to lint. This argument will only work if all of the file paths are in the same folder as this script.\")\n+    args = parser.parse_args()\n+    \n+    # generate responses for each source file and then return their list\n+    srcs, _ = generate_response(args.file_path)\n+\n+    with open('fixed_sources.txt', 'w') as f:\n+        for src in srcs:\n+            f.write(src + '\\n\\n')\n+\n+\n+if __name__ == \"__main__\":\n+    main()",
        "start_line": 67,
        "end_line": 67
    },
    "E0701 - Bad except clauses order (Exception is an ancestor class of ValueError)": {
        "diff": "--- \n+++ \n@@ -1 +1,6 @@\n-    except ValueError:  # Bad except clauses order (E0701)\n+ \"\"\"\n+        return \"\"\n+\n+    @staticmethod\n+    def get_linter() -> Linter:\n+        return LinterPylintFixerLinter()",
        "start_line": 69,
        "end_line": 69
    },
    "R1710 - Either all return statements in a function should return an expression, or none of them should.": {
        "diff": "--- \n+++ \n@@ -1 +1 @@\n-def do_front(front_filename, back_filename):\n+",
        "start_line": 50,
        "end_line": 50
    }
}