{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,10 @@\n-    main()\n+\n+\"\"\"\n+\n+\n+# # The Solution 1 \n+\n+def main():\n+    print(\"main()\")\n+\n+    return \"\"",
        "start_line": 112,
        "end_line": null
    },
    "C0103 - Module name \"E0701-raising_improper_types\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,112 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                back_pixel = back.get_pixel(x, y)\n-                image.set_pixel(x, y, back_pixel)\n-    if image.width == 0:\n-        raise \"Width is zero\"  # Raising improper types (E0702)\n-    return image\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "E0702 - Raising str while only classes or instances are allowed": {
        "diff": "--- \n+++ \n@@ -1 +1,8 @@\n-        raise \"Width is zero\"  # Raising improper types (E0702)\n+\n+\n+            Here are the final files that you need to submit with your solution:\n+            - Code in the original file\n+            - The pylint report on the original file\n+            - The corrected version of the code and its pylint report\n+            \"\"\"\n+        return f\"**STRICTLY FOLLOW THE RULES BELOW:**\\n- Do not introduce unrelated code, or unrelated fixes.\\n- Every function should have a docstring. If missing, add a docstring to the function.\\n- Don'T uncomment code that is commented out.\\n- Don't just say \\\"insert original code here\\\", actually provide the corrected code.\\n- Don't change the functionality of the code. As in, for example, don't just make a recursive function iterative because you want to when that was not prompted by the linter.\\n- If a line or variable needs to be removed, clearly indicate it.\\n- Return only the corrected code within the specific markers, and provide a rationale for each change.\\n- Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\\n- If a linting rule requires you to break up a line of code or add a line, please do so.\\n- Do not put random imports that were not part of the original code.\\n- Do not just leave sections of the code to be filled in by the user; fully complete the code.\\n- Do not just disable the linter warning but actually fix it\\n- It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\\nReturn the response in the following format:\\n```python\\n<corrected code>\\n```\"",
        "start_line": 66,
        "end_line": 66
    }
}