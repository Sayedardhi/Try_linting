{
    "C0301 - Line too long (107/100)": {
        "diff": "--- \n+++ \n@@ -1,47 +1,3 @@\n-    except InvalidException as e:  # Catching an exception which doesn\u2019t inherit from BaseException (E0712)\n-        print(f\"Caught an invalid exception: {e}\")\n \n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n \n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()\n+            ",
        "start_line": 72,
        "end_line": null
    },
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,93 @@\n-    main()\n+405\n+\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+            - Do not introduce unrelated code, or unrelated fixes.\n+            - Every function should have a docstring. If missing, add a docstring to the function.\n+            - Don'nt uncomment code that is commented out.\n+            - Don't just say \"insert original code here\", actually provide the corrected code.\n+            - Don't change the functionality of the code. As in, for example, don'nt just make a recursive function iterative because you want to when that was not prompted by the linter. \n+            - If a line or variable needs to be removed, clearly indicate it.\n+            - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+            - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+            - If a linting rule requires you to break up a line of code or add a line, please do so.\n+            - Do not put random imports that were not part of the original code.\n+            - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+            - Do not just disable the linter warning but actually fix it\n+            - It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\n+            Return the response in the following format:\n+            ```python\n+            <corrected code>\n+            ```\n+            406\n+\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+            - Do not introduce unrelated code, or unrelated fixes.\n+            - Every function should have a docstring. If missing, add a docstring to the function.\n+            - Don'nt uncomment code that is commented out.\n+            - Don't just say \"insert original code here\", actually provide the corrected code.\n+            - Don't change the functionality of the code. As in, for example, don'nt just make a recursive function iterative because you want to when that was not prompted by the linter. \n+            - If a line or variable needs to be removed, clearly indicate it.\n+            - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+            - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+            - If a linting rule requires you to break up a line of code or add a line, please do so.\n+            - Do not put random imports that were not part of the original code.\n+            - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+            - Do not just disable the linter warning but actually fix it\n+            - It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\n+            Return the response in the following format:\n+            ```python\n+            <corrected code>\n+            ```\n+            407\n+\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+            - Do not introduce unrelated code, or unrelated fixes.\n+            - Every function should have a docstring. If missing, add a docstring to the function.\n+            - Don'nt uncomment code that is commented out.\n+            - Don't just say \"insert original code here\", actually provide the corrected code.\n+            - Don't change the functionality of the code. As in, for example, don'nt just make a recursive function iterative because you want to when that was not prompted by the linter. \n+            - If a line or variable needs to be removed, clearly indicate it.\n+            - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+            - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+            - If a linting rule requires you to break up a line of code or add a line, please do so.\n+            - Do not put random imports that were not part of the original code.\n+            - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+            - Do not just disable the linter warning but actually fix it\n+            - It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\n+            Return the response in the following format:\n+            ```python\n+            <corrected code>\n+            ```\n+            408\n+\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+            - Do not introduce unrelated code, or unrelated fixes.\n+            - Every function should have a docstring. If missing, add a docstring to the function.\n+            - Don'nt uncomment code that is commented out.\n+            - Don't just say \"insert original code here\", actually provide the corrected code.\n+            - Don't change the functionality of the code. As in, for example, don'nt just make a recursive function iterative because you want to when that was not prompted by the linter. \n+            - If a line or variable needs to be removed, clearly indicate it.\n+            - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+            - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+            - If a linting rule requires you to break up a line of code or add a line, please do so.\n+            - Do not put random imports that were not part of the original code.\n+            - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+            - Do not just disable the linter warning but actually fix it\n+            - It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\n+            Return the response in the following format:\n+            ```python\n+            <corrected code>\n+            ```\n+            409\n+\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+            - Do not introduce unrelated code, or unrelated fixes.\n+            - Every function should have a docstring. If missing, add a docstring to the function.\n+            - Don'nt uncomment code that is commented out.\n+            - Don't just say \"insert original code here\", actually provide the corrected code.\n+            - Don't change the functionality of the code. As in, for example, don'nt just make a recursive function iterative because you want to when that was not prompted by the linter. \n+            - If a line or variable needs to be removed, clearly indicate it.\n+            - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+            - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+            - If a linting rule requires you to break up a line of code or add a line, please do so.\n+            - Do not put random imports that were not part of this section section section section section section section section section section section section section section section section section section section section section section section section section section section section section section section",
        "start_line": 118,
        "end_line": null
    },
    "C0103 - Module name \"E0712-catching_invalid_exception\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,118 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-class InvalidException:\n-    \"\"\"\n-    Custom exception class that doesn't inherit from BaseException.\n-    \"\"\"\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    try:\n-        image = SimpleImage(front_filename)\n-        back = SimpleImage(back_filename)\n-        for y in range(image.height):\n-            for x in range(image.width):\n-                pixel = image.get_pixel(x, y)\n-                if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                    back_pixel = back.get_pixel(x, y)\n-                    image.set_pixel(x, y, back_pixel)\n-        return image\n-    except InvalidException as e:  # Catching an exception which doesn\u2019t inherit from BaseException (E0712)\n-        print(f\"Caught an invalid exception: {e}\")\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "E0712 - Catching an exception which doesn't inherit from Exception: InvalidException": {
        "diff": "--- \n+++ \n@@ -1 +1,3 @@\n-    except InvalidException as e:  # Catching an exception which doesn\u2019t inherit from BaseException (E0712)\n+\n+'''\n+",
        "start_line": 72,
        "end_line": 72
    },
    "R1710 - Either all return statements in a function should return an expression, or none of them should.": {
        "diff": "--- \n+++ \n@@ -1 +1,171 @@\n-def do_front(front_filename, back_filename):\n+ \"\"\"\n+\n+            if front_filename == back_filename:\n+                return f'{front_filename}'\n+\n+            # Check if it is an empty file\n+            if os.stat(back_filename).st_size == 0:\n+                return None\n+\n+            with open(front_filename, 'r') as f_fr:\n+                code = f_fr.readlines()\n+            with open(back_filename, 'r') as f_bk:\n+                expected_code = f_bk.readlines()\n+\n+            # check if the files are exactly same\n+            if code == expected_code:\n+                return None\n+\n+            corrected_code = []\n+            rationale = \"\"\n+            # check if the files are different and needs to be fixed\n+            for i, line in enumerate(expected_code):\n+                if \"DO NOT MODIFY\" in line or \"FIX ME\" in line or \"INSERT ORIGINAL CODE HERE\" in line:\n+                    # get the index of start\n+                    begin = line.find(\"DO NOT MODIFY\")\n+                    end = line.find(\"FIX ME\")\n+                    if begin == -1 and end != -1:\n+                        begin = line.find(\"INSERT ORIGINAL CODE HERE\")\n+\n+                    rationale = f'```\\n{line}\\n```'\n+                    if begin == -1 or (begin + 20) < len(line):\n+                        corrected_code.append(line[:begin])\n+                        corrected_code.append(\"\")\n+                        corrected_code.append(\"DO NOT MODIFY\")\n+                        corrected_code.append(\"\")\n+                        corrected_code.append(\"FIX ME\")\n+                    else:\n+                        corrected_code.append(line[:begin] + line[begin:])\n+\n+                    # get the index of end and add it to rationale\n+                    for j in range(i, i+2):\n+                        if len(code) > j:\n+                            corrected_code.append(f\"{j}: {code[j]}\")\n+                else:\n+                    corrected_code.append(line)\n+\n+            return '\\n'.join(corrected_code) + f'\\n\\n{rationale}'\n+\n+        # If the files are exactly same, just return the correct filename\n+        if front_filename == back_filename:\n+            return f'{front_filename}'\n+        \n+        response = await self._send_message(ctx, 'Please provide the path to the front file and the path to the back file')\n+        path_to_front = response.content\n+\n+        response = await self._send_message(ctx, 'Please provide the path to the expected file')\n+        path_to_back = response.content\n+        \n+        # Get the pylint report from the file\n+        response = await self._send_message(ctx, f'Running pylint on {path_to_front}')\n+        report = await self.pylint(path_to_front)\n+\n+        # If it is not a valid report, then just return None\n+        if not report:\n+            return None\n+        \n+        # Check if the expected code and the actual code are same or needs to be corrected\n+        if not check_files(path_to_front, path_to_back, report):\n+            return f'```\\n{report}\\n```'\n+\n+        return None\n+\n+    @commands.command()\n+    async def update_pylint_rules(self, ctx):\n+        \"\"\"Update the pylint rules to their current version.\"\"\"\n+        response = await self._send_message(ctx, 'Updating the pylint rules')\n+        report = subprocess.run('pylint --load-plugins=pylint_django', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        if report.returncode != 0:\n+            return None\n+        \n+        await self._send_message(ctx, 'Updated the pylint rules')\n+\n+    @commands.command()\n+    async def check_format(self, ctx):\n+        \"\"\"Check whether there is any formatting errors in the code.\"\"\"\n+        response = await self._send_message(ctx, 'Checking format of the files...')\n+        report = subprocess.run('black .', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        if report.returncode != 0:\n+            return None\n+        \n+        await self._send_message(ctx, 'Checked successfully')\n+    \n+    @commands.command()\n+    async def update_format_rules(self, ctx):\n+        \"\"\"Update the format rules to their current version.\"\"\"\n+        response = await self._send_message(ctx, 'Updating formatting rules')\n+        report = subprocess.run('black --check .', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        if report.returncode != 0:\n+            return None\n+        \n+        await self._send_message(ctx, 'Updated the formatting rules')\n+\n+    @commands.command()\n+    async def update_all(self, ctx):\n+        \"\"\"Update all of the above.\"\"\"\n+        response = await self._send_message(ctx, 'Updating the pylint rules...')\n+        report = subprocess.run('pylint --load-plugins=pylint_django', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        if report.returncode != 0:\n+            return None\n+        \n+        response = await self._send_message(ctx, 'Updating formatting rules...')\n+        report = subprocess.run('black --check .', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        if report.returncode != 0:\n+            return None\n+        \n+        await self._send_message(ctx, 'Updated all the files')\n+\n+    @commands.command()\n+    async def check_test(self, ctx):\n+        \"\"\"Check whether there is any test related errors in the code.\"\"\"\n+        response = await self._send_message(ctx, 'Checking test files...')\n+\n+        # Check the test cases of the front and back end\n+        for file_name in os.listdir('backend/tests/'):\n+            if file_name != '__init__.py' and '.test' not in file_name:\n+                subprocess.run(f'pytest backend/tests/{file_name}', shell=True)\n+\n+        # Check the test cases of the front end\n+        for file_name in os.listdir('frontend/tests/'):\n+            if file_name != '__init__.py' and '.test' not in file_name:\n+                subprocess.run(f'pytest frontend/tests/{file_name}', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        response = await self._send_message(ctx, 'Checked successfully')\n+\n+    @commands.command()\n+    async def update_test(self, ctx):\n+        \"\"\"Update the test files to their current version.\"\"\"\n+        response = await self._send_message(ctx, 'Updating test files...')\n+\n+        # Check the test cases of the front and back end\n+        for file_name in os.listdir('backend/tests/'):\n+            if file_name != '__init__.py' and '.test' not in file_name:\n+                subprocess.run(f'pytest backend/tests/{file_name}', shell=True)\n+\n+        # Check the test cases of the front end\n+        for file_name in os.listdir('frontend/tests/'):\n+            if file_name != '__init__.py' and '.test' not in file_name:\n+                subprocess.run(f'pytest frontend/tests/{file_name}', shell=True)\n+\n+        # If it is not a valid report, then just return None\n+        response = await self._send_message(ctx, 'Updated successfully')\n+\n+    @commands.command()\n+    async def update_all_test(self, ctx):\n+        \"\"\"Update all of the above.\"\"\"\n+        response = await self._send_message(ctx, 'Updating test files...')\n+\n+        # Check the test cases of the front and back on of 10000000',\n+if __name__ == '__' == '__ '__ '__ '__ '__ '__ '__':\n+    print('You have to run this script with the root user (sudo or sudo)')')')')')')')')')')')')')')')')')')')')')')')')')')')')')')')')",
        "start_line": 55,
        "end_line": 55
    }
}