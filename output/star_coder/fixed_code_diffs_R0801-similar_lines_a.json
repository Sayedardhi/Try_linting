{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,33 @@\n-    common_function()\n+2) In case of multiple corrections, return only one. \n+            Here is the code:\n+                common_function()\n+\n+            Here is the pylint report:\n+            Final newline missing\n+            Docstring should start with a single '#'.\n+            Missing module docstring (missing-docstring)\n+\n+            You can fix all issues in one go by running the following command:\n+            \n+```bash\n+            $ python -m pylint --load-plugins pylint_fixer.fixes -E <file name>\n+```\n+            \n+            **If you get an error message that says \"no plugin found\" then:**\n+            1) Make sure that there is a line in your .pylintrc file (and .pylintrci for windows users). This should be something like this:\n+            ```text\n+                [MASTER]\n+                plugins = pylint_fixer.fixes\n+            ```\n+            2) If you are using the latest version of Pylint, make sure to use the plugin as a module name instead of pylint-plugin.\n+            \n+            **If you get an error message that says \"error while loading plugin pylint_fixer.fixes\" then:**\n+            It means that there is some problem with your .pylintrc file (or .pylintrci for windows users) or with the way we have specified the plugins. \n+            Make sure to follow the above instructions and fix your .pylintrc as stated above.\n+            3) If you are still getting this error, it means that Pylint is not able to find our plugin, so please raise an issue at https://github.com/shubham14bajpai/python-linters\n+\n+            **If all the above steps fail:**\n+            Raise an issue at https://github.com/shubham14bajpai/python-linters\n+            \n+            I will be very happy to fix this for you and make your life easier!\n+        \"\"\"",
        "start_line": 13,
        "end_line": null
    },
    "C0103 - Module name \"R0801-similar_lines_a\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,13 +1,16 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example A\n-Shows front and back strategies.\n-\"\"\"\n \n-def common_function():\n-    for i in range(10):\n-        print(\"This is a similar line in multiple files.\")\n-\n-if __name__ == '__main__':\n-    common_function()\n+            **STRICTLY FOLLOW THE RULES BELOW:**\n+    - Do not introduce unrelated code, or unrelated fixes.\n+    - Every function should have a docstring. If missing, add a docstring to the function.\n+    - Don't uncomment code that is commented out.\n+    - Don't just say \"insert original code here\", actually provide the corrected code.\n+    - Don't change the functionality of the code. As in, for example, don'y just make a recursive function iterative because you want to when that was not prompted by the linter. \n+    - If a line or variable needs to be removed, clearly indicate it.\n+    - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+    - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+    - If a linting rule requires you to break up a line of code or add a line, please do so.\n+    - Do not put random imports that were not part of the original code.\n+    - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+    - Do not just disable the linter warning but actually fix it\n+    \"\"\"",
        "start_line": 1,
        "end_line": null
    },
    "C0116 - Missing function or method docstring": {
        "diff": "--- \n+++ \n@@ -1 +1,99 @@\n-def common_function():\n+\n+\n+            If you need any clarification, feel free to ask me about it.\n+        \"\"\"\n+\n+        original_code = get_function(self.__original_filename)\n+        pylint_report = get_pylint_report(self.__pylint_filename)\n+        \n+        corrected_code = self._fix_pylint_errors(original_code, pylint_report)\n+        \n+        return str(corrected_code)\n+\n+\n+    def _fix_pylint_errors(self, original_code: str, pylint_report: list[str]) -> str:\n+        \"\"\"\n+            The function is called when the linter reports issues. It takes a string of the original code and a list of strings of the pylint report as arguments. \n+            Each element in the list is one line from the pylint report for that specific issue. \n+            This function will return the corrected code with all the fixes to make the report disappear, by replacing each error message with its correction.\n+\n+            Parameters\n+            ----------\n+            original_code: str\n+                The string of the original code. It has been already edited.\n+            pylint_report: list[str]\n+                A list of strings that contain one line from the report for every issue found by the linter.\n+                Example:\n+                    ```python\n+                        Missing function or method docstring\n+\n+                        **STRICTLY FOLLOW THE RULES BELOW:**\n+                         - Do not introduce unrelated code, or unrelated fixes.\n+                         - Every function should have a docstring. If missing, add a docstring to the function.\n+                         - Don't uncomment code that is commented out.\n+                         - Don't just say \"insert original code here\", actually provide the corrected code.\n+                         - Don't change the functionality of the code. As in, for example, don't just make a recursive function iterative because you want to when that was not prompted by the linter. \n+                         - If a line or variable needs to be removed, clearly indicate it.\n+                         - Return only the corrected code within the specific markers, and provide a rationale for each change.\n+                         - Add a module docstring at the beginning of the code if missing, as suggested by the linter. You can use the name of the file as the module name.\n+                         - If a linting rule requires you to break up a line of code or add a line, please do so.\n+                         - Do not put random imports that were not part of the original code.\n+                         - Do not just leave sections of the code to be filled in by the user; fully complete the code.\n+                         - Do not just disable the linter warning but actually fix it\n+                         - It is imperative that you do not change the functionality of the code unless directly needed by the linter. So keep most of the code from the original file and fix what's needed. This is imperative, as the code is being linted for a specific purpose, and changing the functionality could have unintended consequences.\n+                    ```\n+            Returns\n+            ----------\n+            str\n+                The corrected code.\n+        \"\"\"\n+\n+        # We start by creating a dictonary with all possible rules that were found by the linter. \n+        # Each key in this dictionary is the rule name (lowercase), while each value in it is a tuple of two strings:\n+        # - The first string contains the error message to display on the output file.\n+        # - The second string is the corresponding correction for that error message, which will be used as a fix. \n+        rules_to_fix = {\n+            'missing-function-docstring': ('Missing function or method docstring', ''),\n+            'too-few-public-methods': (\n+                'This module lacks sufficient public methods to be considered a Python module.', \n+                f'Create at least {rules[\"too-few-public-methods\"][1]} public methods.' \n+            ),\n+            'too-many-arguments': ('Too many arguments', ''),\n+            'no-self-argument': ('No self argument', f'Add the keyword argument `self` to your method call.'),\n+            'invalid-name': (\n+                'Invalid name \"%s\"', \n+                f'Rename variable, function or class to not have this prefix: `{rules[\"invalid-name\"][1]}` and make sure that it starts with a lower case letter.' \n+            ),\n+            'missing-module-docstring': ('Missing module docstring', ''),\n+            'line-too-long': ('Line too long', f'Wrap the lines of the method or class in at most {rules[\"line-too-long\"][1]} characters.'),\n+            'unnecessary-pass': (\n+                'Unnecessary pass statement found.', \n+                f'Remove this empty line.' \n+            ),\n+        }\n+\n+        # We create a list to store the fixes for each line, so we can easily check which one is applicable. \n+        fixes = []\n+        for i in range(len(pylint_report)):\n+            error_type: str = pylint_report[i].split(\":\")[0]\n+\n+            if error_type not in rules_to_fix:\n+                continue\n+            \n+            fixes.append((pylint_report[i], rules_to_fix[error_type][1]))\n+\n+        # Now, we can start looping over each line of the corrected code and apply all the fixes for that line.\n+        for i in range(len(original_code)):\n+            original_line = original_code[i]\n+\n+            if original_line not in rules_to_fix:\n+                continue\n+            \n+            for j in range(len(fixes)):\n+\n+                # The error message is at position 0 of the tuple, and the corresponding fix is at position 1. \n+                # If the line is equal to the one of the error message (at index 0), we can apply the corresponding correction on the correct line.\n+                if original_line == fixes[j][0].split(\":\")[0]:\n+                    corrected_code = original_code[:i] + fixes[j][1] + original_code[(i+1):]\n+\n+        return corrected_code",
        "start_line": 8,
        "end_line": 8
    },
    "W0612 - Unused variable 'i'": {
        "diff": "--- \n+++ \n@@ -1 +1,17 @@\n-    for i in range(10):\n+\n+\n+        \"\"\"\n+        # TODO: Write the function to fix this issue. Remember to return the corrected code.\n+        # TODO: Use the docstring above as a guide, and use any additional methods you want.\n+        # TODO: You can also do your own preprocessing of the file if that is more convenient.\n+        self.pre_process_file(filename)\n+        output = \"\"\n+        with open(filename, 'r') as f:\n+            for i in range(10):\n+                line = f.readline()\n+                if not line:\n+                    break\n+                else:\n+                    output += str(line)\n+\n+        return output",
        "start_line": 9,
        "end_line": 9
    }
}