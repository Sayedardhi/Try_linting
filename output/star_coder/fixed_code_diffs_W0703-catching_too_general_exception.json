{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,33 @@\n+\n+          \"\"\"\n+        return \"\\n\".join(self.fixer.correct())\n+\n+    def __repr__(self):\n+        return self.__str__()\n+\n+\n+def main():\n+    # Read file content and store it in a string variable\n+    with open(\"code/main.py\", \"r\") as f:\n+        code = f.read()\n+\n+    # Initialize the pylint class, and pass the filename to check against\n+    lint_tool = Pylint(filename=\"code/main.py\")\n+\n+    # Run the code through the linter, and store the report in a variable called 'report'\n+    report = lint_tool.run(code)\n+    \n+    # Print out the corrected code. If there is an error, print out the message we got back from pylint,\n+    # otherwise, print out the final report!\n+    if report == \"Ok\":\n+        print(\"Your code is good to go!\")\n+        print(\"The original code: \\n{}\".format(code))\n+        print(\"The corrected code: \\n{}\".format(lint_tool.fix()))\n+    \n+    else:\n+        print(\"Oh noes, something went wrong.\")\n+        print(f\"There was an error message from pylint:\\n {report}\")\n+\n+\n+if __name__ == \"__main__\":\n     main()",
        "start_line": 113,
        "end_line": null
    },
    "C0103 - Module name \"W0703-catching_too_general_exception\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,113 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    try:\n-        image = SimpleImage(front_filename)\n-        back = SimpleImage(back_filename)\n-        for y in range(image.height):\n-            for x in range(image.width):\n-                pixel = image.get_pixel(x, y)\n-                if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                    back_pixel = back.get_pixel(x, y)\n-                    image.set_pixel(x, y, back_pixel)\n-        return image\n-    except Exception as e:  # Catching too general exception (W0703)\n-        print(f\"An error occurred: {e}\")\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "W0718 - Catching too general exception Exception": {
        "diff": "--- \n+++ \n@@ -1 +1,41 @@\n-    except Exception as e:  # Catching too general exception (W0703)\n+ \"\"\"\n+            self.logger.info(f\"Starting fixer for file {self.filename}\")\n+\n+            with open(self.filename) as file:\n+                lines = file.readlines()\n+            \n+            # Parse and check for valid syntax before we can start linting. If there is an error, stop the linter and exit immediately.\n+            self.parse_and_check(lines)\n+\n+            # Add a docstring to each function in the code. This is not strictly necessary for pylint but it helps with debugging.\n+            if self.docstring_missing:\n+                lines = add_docstrings(lines)\n+            \n+            # Remove unnecessarily indented blocks of code\n+            lines = remove_unindented_blocks(lines)\n+\n+            # Add comments to explain why the code is indented so that we know what the user should expect when reading it. This is not strictly necessary for pylint but it helps with debugging.\n+            if self.docstring_missing:\n+                lines = add_comments(lines)\n+            \n+            # Lint the code and fix all the errors\n+            corrected, report = pylint_fixer(self.filename, lines)\n+\n+            # Remove comments to explain why the code is indented so that we know what the user should expect when reading it. This is not strictly necessary for pylint but it helps with debugging.\n+            if self.docstring_missing:\n+                lines = remove_comments(lines)\n+            \n+            # Remove unnecessarily indented blocks of code\n+            lines = remove_unindented_blocks(lines)\n+\n+            # Add a docstring to each function in the code. This is not strictly necessary for pylint but it helps with debugging.\n+            if self.docstring_missing:\n+                lines = add_docstrings(lines)\n+\n+            response = \"\"\n+            for line in corrected:\n+                response += f\"{line}\\n\"\n+            \n+            response += \"\\n\" + report\n+            \n+            return response",
        "start_line": 67,
        "end_line": 67
    },
    "R1710 - Either all return statements in a function should return an expression, or none of them should.": {
        "diff": "--- \n+++ \n@@ -1 +1,147 @@\n-def do_front(front_filename, back_filename):\n+\n+\"\"\"\n+\n+\n+from ast import parse\n+from collections import defaultdict\n+from pathlib import Path\n+from typing import Any, Dict, List, NamedTuple, Optional, Sequence, Tuple\n+import subprocess\n+import sys\n+\n+class PylintResult(NamedTuple):\n+    code: str\n+    report_path: Path\n+\n+    def __str__(self) -> str:\n+        return self.code\n+\n+\n+def do_front(front_filename: Path, back_filename: Path) -> None:\n+    if front_filename == back_filename:\n+        print(\"Original and corrected code are the same file, so can't fix it\")\n+\n+    with open(back_filename, \"r\") as f:\n+        corrected = f.read()\n+\n+    try:\n+        report = subprocess.check_output(\n+            [\"pylint\", \"--disable=all\", back_filename], stderr=subprocess.STDOUT\n+        )\n+    except subprocess.CalledProcessError:\n+        print(\"Linter failed to run on the code. Will not fix\")\n+        return\n+\n+    original_code = get_original_code(back_filename)\n+\n+    report_path = Path(sys.argv[0]).parent / Path(front_filename).with_suffix(\".report\")\n+    with open(report_path, \"w\") as f:\n+        f.write(str(report))\n+\n+    # Parse the pylint report and get the rationale for each fix\n+    original_to_fix = get_original_to_fixed()\n+    fixes = get_fixes(report_path)\n+    corrected_lines = add_line_corrections(corrected, original_code, original_to_fix, fixes)\n+\n+    with open(front_filename, \"w\") as f:\n+        f.write(corrected_lines)\n+\n+def get_original_to_fixed() -> Dict[Tuple[str], str]:\n+    \"\"\"Get a dictionary of the original code to what it is fixed for\"\"\"\n+    original_to_fix = {}\n+\n+    with open(\"original_code.txt\", \"r\") as f:\n+        for line in f:\n+            if not line.startswith(\"#\"):\n+                parts = line.split()\n+                # For each original, get a list of fixes that were made to it\n+                fix_parts = parts[-1].replace('\"', \"\").split(\",\")\n+                # Store the original code and the fix to that specific original code as a key-value pair\n+                original_to_fix[tuple(parts[:-1])] = \" \".join(fix_parts)\n+\n+    return original_to_fix\n+\n+def get_fixes(report_path: Path) -> List[str]:\n+    \"\"\"Parse the pylint report for all of the fixes made to each function\"\"\"\n+    # A map of lines to the number of times they were changed by the linter. So if a line is changed 3 times, then it'll be 4 in this dict\n+    original_to_fix = {}\n+\n+    with open(report_path, \"r\") as f:\n+        for line in f:\n+            if line.startswith(\"************ Module \") or not line.startswith(\"-\"):\n+                continue\n+\n+            # Parse the report line and get the function name and line number of the fix\n+            parts = line.split()\n+            function_name = parts[1]\n+            line_number = int(parts[-4])\n+\n+            # Get the original code to that specific line number\n+            original_code = original_to_fix[(function_name, line_number)]\n+\n+            # Parse the report line and get the fix message\n+            message = \" \".join(parts[-2:])\n+\n+            if len(original_code) > 0:\n+                original_code += f\" - {message}\"\n+            else:\n+                original_code = message\n+\n+    return [original_code]\n+\n+def add_line_corrections(\n+    corrected: str, \n+    original_code: str, \n+    original_to_fix: Dict[Tuple[str], str], \n+    fixes: List[str]\n+) -> str:\n+    \"\"\"Add the original code to each line in the corrected code\"\"\"\n+    lines = []\n+\n+    for i, line in enumerate(corrected.splitlines()):\n+        if i == 0 and len(original_code) > 0:\n+            lines.append(\"# Original Code\" + \"\\n\")\n+            lines.append(\"###############\\n\")\n+            lines.append(\"# \" + original_code + \"\\n\")\n+            lines.append(\"###############\\n\")\n+\n+        line = line.replace(\"\\t\", \" \")\n+        if line == \"# Original Code\":\n+            pass\n+        elif len(line) > 0 and line[0] != \"#\":\n+            # Get the fix for this line number, if there is one\n+            fixed_line = original_to_fix[(original_code[:3], i+1)]\n+\n+            if len(fixed_line) > 0:\n+                lines.append(fixed_line + \"\\n\")\n+\n+        lines.append(line + \"\\n\")\n+\n+    return \"\".join(lines)\n+\n+def get_original_code(filename: Path) -> str:\n+    \"\"\"Get the original code for a specific file\"\"\"\n+    with open(\"original_code.txt\", \"r\") as f:\n+        lines = []\n+        for line in f:\n+            if not line.startswith(\"#\"):\n+                parts = line.split()\n+                # For each original, get a list of fixes that were made to it\n+                fix_parts = parts[-1].replace('\"', \"\").split(\",\")\n+                # Store the original code and the fix to that specific original code as a key-value pair\n+                if tuple(parts[:-1]) == (filename.stem, str(i+1)):\n+                    original_code = \" \".join(fix_parts)\n+\n+    return original_code\n+\n+def main() -> None:\n+    \"\"\"Run this script\"\"\"\n+    # Get the arguments\n+    front_filename = Path(\"front.py\")\n+    back_filename = Path(sys.argv[1])\n+\n+    do_front(front_filename, back_filename)\n+\n+\n+if __name__ == \"__main__\":\n+    main()",
        "start_line": 50,
        "end_line": 50
    }
}