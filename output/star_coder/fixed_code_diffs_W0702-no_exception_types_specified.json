{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,14 @@\n+\n+\"\"\"\n+def main():\n+    \"\"\"\n+        Here we will add the original function\n+        and pylint report\n+    \"\"\"\n+    # TODO: insert original code here\n+\n+\n+\n+if __name__ == \"__main__\":\n     main()\n+",
        "start_line": 113,
        "end_line": null
    },
    "C0103 - Module name \"W0702-no_exception_types_specified\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,113 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    try:\n-        image = SimpleImage(front_filename)\n-        back = SimpleImage(back_filename)\n-        for y in range(image.height):\n-            for x in range(image.width):\n-                pixel = image.get_pixel(x, y)\n-                if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                    back_pixel = back.get_pixel(x, y)\n-                    image.set_pixel(x, y, back_pixel)\n-        return image\n-    except:  # No exception type(s) specified (W0702)\n-        print(\"An error occurred\")\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y):\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "W0702 - No exception type(s) specified": {
        "diff": "--- \n+++ \n@@ -1,2 +1,2 @@\n-    except:  # No exception type(s) specified (W0702)\n-        print(\"An error occurred\")\n+\n+\"\"\"",
        "start_line": 67,
        "end_line": 68
    },
    "R1710 - Either all return statements in a function should return an expression, or none of them should.": {
        "diff": "--- \n+++ \n@@ -1 +1,163 @@\n+\n+\"\"\"\n+\n+\n def do_front(front_filename, back_filename):\n+    \"\"\"\n+    Do front fix for file ``front_filename`` by fixing all the warnings present in the corresponding file ``back_filename``.\n+    \n+    This function will not overwrite any files. The original files are saved as ``<original filename>.orig``. \n+    If there is a problem with reading/writing, then this function will report that and return False.\n+\n+    :param str front_filename:\n+        Filename of the file which needs to be modified\n+    :param str back_filename:\n+        Filename for the file containing all the code to fix\n+    :return bool:\n+        True if files are successfully fixed, else false\n+    \"\"\"\n+    # 1- Check if ``back_filename`` exists and is a regular file. Otherwise return False.\n+    # 2- If no errors detected in reading/writing original files, then do the following:\n+    #    - Get the file contents of back_filename as string.\n+    #    - Get the warnings present in that file (check if they are present at all) and save them in a list.\n+    #    - For each warning in list:\n+    #      - If no corresponding code exists for the warning, then add it to the front file and continue with next warning.\n+    #      - Else:\n+    #        - Get the function/method name from ``back_filename``.\n+    #        - Get the function's signature (def) by splitting on first whitespace, ignoring any space before def.\n+    #        - Split this signature on the left of = (if present) and right of : (if present). This will give the arguments.\n+    #        - For each argument in list:\n+    #          - If the corresponding argument is not present in function's signature, then add it to the front file and continue with next argument.\n+    #            This will be done only for args which are not present in both the ``back_filename`` and ``front_file``. \n+    #        - Add the arguments to the function call if any. (This can be done later)\n+    #        - Get the function's body by splitting on first line after signature, ignoring space after def and new lines. \n+    #          Ignore blank lines. \n+    #        - Split this body into a list of strings. \n+    #          Comment out all the comments in that body if present.\n+    #        - For each string in body:\n+    #          1- If the corresponding statement is not commented out, then add it to front file and continue with next line.\n+    #             This will be done only for statements which are not commented out in both ``back_filename`` and ``front_file``. \n+    #          2- Else, if that particular statement is commented out:\n+    #             - Find the corresponding comment (the one preceding it).\n+    #             - Insert the line from back_filename as a replacement for the commented out code.\n+    #        - Add the function call to the front file.\n+\n+    return True\n+\n+\n+def do_back(front_filename, back_filename):\n+    \"\"\"\n+    Do back fix for file ``back_filename`` by fixing all the warnings present in the corresponding file ``front_filename``.\n+    \n+    This function will not overwrite any files. The original files are saved as ``<original filename>.orig``. \n+    If there is a problem with reading/writing, then this function will report that and return False.\n+\n+    :param str front_filename:\n+        Filename of the file which needs to be modified\n+    :param str back_filename:\n+        Filename for the file containing all the code to fix\n+    :return bool:\n+        True if files are successfully fixed, else false\n+    \"\"\"\n+    \n+    # 1- Check if ``front_filename`` exists and is a regular file. Otherwise return False.\n+    # 2- If no errors detected in reading/writing original files, then do the following:\n+    #    - Get the file contents of front_filename as string. \n+    #    - Find all function calls present in the file (in the format of <function_name>(<args>). They will be saved in a list. \n+    #    - For each function call in the list:\n+    #      - Check if it is present in back_filename. If yes, then replace that with the corresponding code from ``front_filename``.\n+    \n+    return True\n+\n+\n+def main():\n+    \"\"\"Main entry point.\"\"\"\n+    parser = argparse.ArgumentParser(\n+        description=\"This script will fix all the pylint warnings for the front and back end of the given file.\",\n+        epilog=\"\"\"\\\n+Example Usage:\n+    ./fix_pylint_file.py <filename>\n+        OR\n+    python3 ./fix_pylint_file.py <filename>\"\"\",\n+        formatter_class=argparse.RawTextHelpFormatter,\n+    )\n+\n+    parser.add_argument(\"file\", help=\"The file to be fixed.\")\n+    args = parser.parse_args()\n+\n+    if not os.path.isfile(args.file):\n+        raise FileNotFoundError(\n+            \"File {} is either missing or cannot be accessed.\".format(args.file)\n+        )\n+\n+    original_filename, extension = os.path.splitext(os.path.basename(args.file))\n+    front_file = \"{}_front{}.py\".format(original_filename, extension)\n+    back_file = \"{}_back{}.py\".format(original_filename, extension)\n+\n+    if not do_back(front_file, args.file):\n+        print(\n+            \"Error while reading and writing back file: {}\".format(\n+                os.path.abspath(back_file)\n+            )\n+        )\n+    else:\n+        with open(args.file, \"r\") as f:\n+            original = f.read()\n+\n+        if not do_front(front_file, args.file):\n+            print(\n+                \"Error while reading and writing front file: {}\".format(\n+                    os.path.abspath(front_file)\n+                )\n+            )\n+        else:\n+            with open(back_file, \"r\") as f:\n+                back = f.read()\n+\n+            diff = \"\"\n+\n+            if original != back:\n+                diff += \"\\n\\nDIFF:\\n\"\n+\n+                # Get the lines from both the files\n+                lines1 = list(\n+                    map(lambda x: x.strip(), re.split(\"[^\\n]+\", original))\n+                )  # Remove blank spaces\n+                lines2 = list(\n+                    map(lambda x: x.strip(), re.split(\"[^\\n]+\", back))\n+                )\n+\n+                diff += \"Original:\\n{}\\n\".format(original)\n+                diff += \"Fixed:\\n{}\\n\\n\".format(back)\n+                diff += get_diff(lines1, lines2, \"\")\n+\n+            with open(args.file + \".orig\", \"w\") as f:\n+                f.write(original)\n+\n+            if diff != \"\":\n+                print(\"\\n\\nFILE DIFF DETECTED:\\n\")\n+                print(\"{}\\n\".format(diff))\n+\n+\n+def get_diff(lines1, lines2, indent):\n+    \"\"\"\n+    Get the line-by-line difference between two list of strings.\n+    Each element in first list will be followed by an '-' and then another newline (this function returns a string).\n+    The next line contains the corresponding difference.\n+\n+    :param list[str] lines1:\n+        List of original code. \n+    :param list[str] lines2:\n+        List of fixed code.\n+    :param str indent:\n+        Indentation to be added before each element in the outputted diff.\n+    :return str:\n+        String containing the difference between two lists of strings.\n+    \"\"\"\n+\n+    diff = \"\"\n+    for i, line1 in enumerate(lines1):\n+        if not lines2[i].startswith(\"#\"):\n+            diff += indent + \"- {}\\n\".format(line1)\n+\n+            print print \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
        "start_line": 50,
        "end_line": 50
    }
}