{
    "C0304 - Final newline missing": {
        "diff": "--- \n+++ \n@@ -1 +1,190 @@\n+\n+\"\"\"\n+# pylint: disable=wrong-import-position\n+from .utils import (\n+    create_file_if_not_exists,\n+    get_all_files,\n+    get_code_lines,\n+    replace_line,\n+    remove_line,\n+    insert_code,\n+    get_function_name_by_path,\n+    get_full_filepath_by_relative_path,\n+)\n+\n+\n+def main():\n+    \"\"\" Main function. Reads the files and fixes linting issues.\n+\n+    The files are parsed for functions and their code is checked against the provided rules (rules.py). \n+    If there's a rule that matches with the code then it will be replaced or removed accordingly in the file.\n+\n+    Args:\n+        None\n+\n+    Returns:\n+        None\n+    \"\"\"\n+\n+    # Create main directory if not exists\n+    create_file_if_not_exists()\n+\n+    for filepath in get_all_files():\n+        print(f\"Processing File: {filepath}\")\n+\n+        # Get code lines in file and store them in a list.\n+        code_lines = get_code_lines(get_full_filepath_by_relative_path(filepath))\n+\n+        function_name = get_function_name_by_path(filepath)\n+\n+        # Check if the file has a function. If it doesn't, just move on to next.\n+        if function_name:\n+\n+            # Get all rules that match with the function code.\n+            rules = get_all_rules_for_function_code(get_full_filepath_by_relative_path(filepath), function_name)\n+\n+            # Apply all rules for current file and store in new list of code lines to be saved.\n+            fixed_code_lines = fix_file_for_rules(code_lines, rules)\n+\n+            # Replace the old code with the fixed one.\n+            replace_in_file(get_full_filepath_by_relative_path(filepath), function_name, fixed_code_lines)\n+\n+        else:\n+            print(\"No functions in this file.\")\n+\n+\n+def get_all_rules_for_function_code(filepath, function_name):\n+    \"\"\" Returns all rules that match with the function code.\n+\n+    Args:\n+        filepath (string): The path of the current file being processed.\n+        function_name (string): Name of the function in the current file.\n+\n+    Returns:\n+        list: List of all rules for the function and their corrections/removes.\n+    \"\"\"\n+\n+    # Get function start line and end line for the code to check against rules.\n+    start_line, end_line = get_start_end_line(filepath, function_name)\n+\n+    rules = []\n+\n+    for rule in Rules:\n+        if rule.rule_match(get_code_lines(get_full_filepath_by_relative_path(filepath))):\n+            fixed_code = insert_code(\n+                rule.rule_replacement(),\n+                get_code_lines(get_full_filepath_by_relative_path(filepath))[start_line - 1],\n+            )\n+\n+            # If the replacement is not None then create a new Rule object and add it to the list of rules that will be applied later on.\n+            if fixed_code:\n+                rules.append(Rule(get_full_filepath_by_relative_path(filepath), start_line, end_line, rule.rule_description(), fixed_code))\n+\n+    return rules\n+\n+\n+def get_start_end_line(filepath, function_name):\n+    \"\"\" Returns the line number of the beginning and ending lines for the code to be checked against linting rules.\n+\n+    Args:\n+        filepath (string): The path of the current file being processed.\n+        function_name (string): Name of the function in the current file.\n+\n+    Returns:\n+        tuple(int, int): Start line and end line number.\n+    \"\"\"\n+\n+    # Find out if the function is defined inside another function or not. \n+    start_line = None\n+    end_line = None\n+\n+    for index, code in enumerate(get_code_lines(get_full_filepath_by_relative_path(filepath))):\n+\n+        if f\"def {function_name}\" in code:\n+            # The function is defined inside another function so find the line number of its start and end.\n+            start_line = index + 1\n+            break\n+\n+    for index, code in enumerate(get_code_lines(get_full_filepath_by_relative_path(filepath))):\n+\n+        if f\"def {function_name}\" in code:\n+            # The function is defined inside another function so find the line number of its start and end.\n+            end_line = index + 1\n+\n+    return start_line, end_line\n+\n+\n+def fix_file_for_rules(code_lines, rules):\n+    \"\"\" Applies all rules for current file to get corrected code and returns it.\n+    \n+    Args:\n+        filepath (string): The path of the current file being processed.\n+        function_name (string): Name of the function in the current file.\n+\n+    Returns:\n+        list: List of new code lines after applying all rules for the function and their corrections/removes.\n+    \"\"\"\n+\n+    corrected_code_lines = []\n+    for index, rule in enumerate(rules):\n+\n+        # If the current line is a comment, then just skip it and continue with next one.\n+        if Rules[index].rule_match(code_lines) == COMMENT:\n+            corrected_code_lines.append(COMMENT)\n+            continue\n+\n+        elif code_lines[index] in rule.get_removed():\n+            corrected_code_lines = remove_line(corrected_code_lines, index + 1, \"Removed the following line\")\n+        else:\n+            corrected_code_lines = replace_line(corrected_code_lines, index + 1, rule.get_replacement())\n+\n+    return corrected_code_lines\n+\n+\n+def replace_in_file(filepath, function_name, fixed_code_lines):\n+    \"\"\" Replaces the code in the file with new ones for all rules that match with current line of code and returns it.\n+\n+    Args:\n+        filepath (string): The path of the current file being processed.\n+        function_name (string): Name of the function in the current file.\n+\n+    Returns:\n+        list: List of new code lines after applying all rules for the function and their corrections/removes.\n+    \"\"\"\n+\n+    with open(filepath, \"r+\") as f:\n+\n+        for index, line in enumerate(fixed_code_lines):\n+\n+            # If the current line is a comment, then just skip it and continue with next one.\n+            if fixed_code_lines[index] == COMMENT:\n+                f.write(line)\n+                f.write(\"\\n\")\n+                continue\n+\n+            elif function_name not in line and \"import\" not in line:\n+\n+                # If the current line doesn't have function or imports then write it as-is. \n+                f.write(fixed_code_lines[index])\n+                f.write(\"\\n\")\n+\n+            else:\n+\n+                # Else, write all lines with original code except for the current line if it has the function name.\n+                f.seek(0)\n+                for line in get_code_lines(get_full_filepath_by_relative_path(filepath)):\n+\n+                    if index < 1 or (function_name not in line and \"import\" not in line):\n+                        # If this is the first iteration, write all code except for the current line. \n+                        f.write(line)\n+                        f.write(\"\\n\")\n+\n+                # Write the corrected code as last.\n+                f.seek(0)\n+                for line in fixed_code_lines:\n+                    f.write(line)\n+                    f.write(\"\\n\")\n+\n+\n+if __name__ == \"__main__\":\n     main()",
        "start_line": 118,
        "end_line": null
    },
    "C0103 - Module name \"C0121-comparison\" doesn't conform to snake_case naming style": {
        "diff": "--- \n+++ \n@@ -1,118 +1 @@\n-#!/usr/bin/env python3\n \n-\"\"\"\n-Stanford Bluescreen Example\n-Shows front and back strategies.\n-The functions are mostly complete,\n-missing only the key if-logic line.\n-\"\"\"\n-\n-import sys\n-from PIL import Image\n-\n-# Deliberately removing required attributes\n-del __doc__\n-\n-\n-class SimpleImage:\n-    \"\"\"\n-    A wrapper class for PIL Image to facilitate pixel manipulation.\n-    \"\"\"\n-    def __init__(self, filename):\n-        \"\"\"\n-        Initialize the SimpleImage with a given filename.\n-        Load the image and get its size.\n-        \"\"\"\n-        self.image = Image.open(filename)\n-        self.pixels = self.image.load()\n-        self.width, self.height = self.image.size\n-\n-    def get_pixel(self, x, y):\n-        \"\"\"\n-        Get the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        return self.pixels[x, y]\n-\n-    def set_pixel(self, x, y, color):\n-        \"\"\"\n-        Set the pixel value at the given (x, y) coordinates.\n-        \"\"\"\n-        self.pixels[x, y] = color\n-\n-    def in_bounds(self, x, y):\n-        \"\"\"\n-        Check if the given (x, y) coordinates are within the image bounds.\n-        \"\"\"\n-        return 0 <= x < self.width and 0 <= y < self.height\n-\n-    def show(self):\n-        \"\"\"\n-        Display the image.\n-        \"\"\"\n-        self.image.show()\n-\n-\n-def do_front(front_filename, back_filename):\n-    \"\"\"\n-    Front strategy: loop over front image,\n-    detect blue pixels there,\n-    substitute in pixels from back.\n-    Return changed front image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] > 2 * max(pixel[0], pixel[1]):\n-                back_pixel = back.get_pixel(x, y)\n-                image.set_pixel(x, y, back_pixel)\n-    return image\n-\n-\n-def do_back(front_filename, shift_x, shift_y, back_filename):\n-    \"\"\"\n-    Back strategy: loop over image,\n-    detect *non-blue* pixels.\n-    Copy those pixels to back, shifted by shift_x, shift_y.\n-    Pixels which fall outside of the background are ignored.\n-    Return changed back image.\n-    \"\"\"\n-    image = SimpleImage(front_filename)\n-    back = SimpleImage(back_filename)\n-    for y in range(image.height):\n-        for x in range(image.width):\n-            pixel = image.get_pixel(x, y)\n-            if pixel[2] <= 2 * max(pixel[0], pixel[1]):\n-                dest_x = x + shift_x\n-                dest_y = y + shift_y\n-                if back.in_bounds(dest_x, dest_y) == True:\n-                    back.set_pixel(dest_x, dest_y, pixel)\n-    return back\n-\n-\n-def main():\n-    \"\"\"\n-    Main function to handle argument parsing and strategy execution.\n-    \"\"\"\n-    args = sys.argv[1:]\n-\n-    if len(args) != 2 and len(args) != 4:\n-        print('Args not recognized. Usage:')\n-        print('2 args for front strategy:')\n-        print('  front-image back-image')\n-        print('4 args for back strategy:')\n-        print('  front-image shift-x shift-y back-image')\n-        return\n-\n-    if len(args) == 2:\n-        image = do_front(args[0], args[1])\n-        image.show()\n-\n-    if len(args) == 4:\n-        image = do_back(args[0], int(args[1]), int(args[2]), args[3])\n-        image.show()\n-\n-\n-if __name__ == '__main__':\n-    main()",
        "start_line": 1,
        "end_line": null
    },
    "C0121 - Comparison 'back.in_bounds(dest_x, dest_y) == True' should be 'back.in_bounds(dest_x, dest_y) is True' if checking for the singleton value True, or 'back.in_bounds(dest_x, dest_y)' if testing for truthiness": {
        "diff": "--- \n+++ \n@@ -1 +1,22 @@\n-                if back.in_bounds(dest_x, dest_y) == True:\n+\n+            \n+        \"\"\"\n+        # TODO write your logic here\n+\n+    def fix_pylint(self, file_name):\n+        \"\"\"\n+        A function to run pylint on a python file and return its report.\n+        \n+        Arguments:\n+        file_name -- The name of the python file to be linted.\n+        \n+        Returns:\n+        report -- The report of the linter for the given file\n+        \"\"\"\n+        # TODO write your logic here\n+\n+        pass\n+\n+\n+if __name__ == \"__main__\":\n+    main()",
        "start_line": 89,
        "end_line": 89
    }
}